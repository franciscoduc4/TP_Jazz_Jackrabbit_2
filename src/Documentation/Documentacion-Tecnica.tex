\documentclass[titlepage,a4paper]{article}
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\usepackage{listings}
\usepackage{color}
\usepackage{pdfpages}
\usepackage{multirow}
\usepackage{plantuml}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage[spanish,es-tabla]{babel}

% Quote box
% for adjustwidth environment
\usepackage[strict]{changepage}

% for formal definitions
\usepackage{framed}

% Add the titlesec package for optional formatting (if needed)
\usepackage{titlesec}

\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{4}


% environment derived from framed.sty: see leftbar environment definition
\definecolor{formalshade}{rgb}{0.95,0.95,1}

\newenvironment{formal}{%
  \def\FrameCommand{%
    \hspace{1pt}%
    {\color{blue}\vrule width 2pt}%
    {\color{formalshade}\vrule width 4pt}%
    \colorbox{formalshade}%
  }%
  \MakeFramed{\advance\hsize-\width\FrameRestore}%
  \noindent\hspace{-4.55pt}% disable indenting first paragraph
  \begin{adjustwidth}{}{7pt}\itshape%
  \vspace{2pt}\vspace{2pt}%
}
{%
  \vspace{2pt}\end{adjustwidth}\endMakeFramed%
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
}

\pagestyle{fancy} % Encabezado y pie de página
\fancyhf{}
\fancyhead[L]{Trabajo Práctico Final | Jazz Jackrabbit 2 | Grupo 5\\Documentación Técnica}
\fancyhead[R]{Taller de Programación I - FIUBA}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\fancypagestyle{firstPage}{%
  \fancyfoot[C]{\thepage}
  \renewcommand{\footrulewidth}{0.4pt}
}

\begin{document}

\begin{titlepage} % Carátula
	\hfill\includegraphics[width=6cm]{logofiuba.jpg}
    \centering
    \vfill
    \Huge \textbf{Trabajo Práctico Final\\Jazz Jackrabbit 2}
    \vskip2cm
    \Large [75.42] Taller de Programación I\\
    Primer Cuatrimestre de 2024
    \vfill
    \begin{tabular}{ | l | l | l | } % Datos del alumno
      \hline
      \textbf{Estudiante} & \textbf{Padrón} & \textbf{Email} \\ \hline
      Buono, Fernando & 103523 & fbuono@fi.uba.ar \\ \hline
      Duca, Francisco & 106308 & fduca@fi.uba.ar \\ \hline
      Oshiro, Lucas & 107024 & loshiro@fi.uba.ar \\ \hline
      Shiao, Tomás Jorge & 106099 & tshiao@fi.uba.ar \\ \hline
  	\end{tabular}
    \vfill
    \vfill
\end{titlepage}

\clearpage\pagestyle{empty}
\tableofcontents % Índice general
\newpage
\setcounter{page}{1}
\pagestyle{fancy}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\section{Introducción}
El proyecto es una implementación del juego Jazz Jackrabbit 2 con soporte multijugador. Los jugadores pueden seleccionar uno de los tres personajes: Jazz, Spaz o Lori, cada uno con habilidades y ataques especiales únicos. El juego incluye la capacidad de disparar, correr, saltar y realizar ataques especiales, así como varios estados como intoxicado, recibir daño y muerte. Además, se incluye un editor de niveles para que se puedan crear nuevos niveles.

\section{Estructura del Proyecto}
El proyecto tiene una estructura de cliente servidor, donde el servidor es el encargado de manejar la lógica del juego y el cliente es el encargado de mostrar la información al usuario. Además, se incluye un editor de niveles que permite crear nuevos niveles para el juego.

\subsection{dependencias}
\begin{enumerate}
  \item CMake: para la compilación del proyecto.
  \item Qt5: para la interfaz gráfica, versión 5.15.
  \item YAML-cpp: para el manejo de archivos de configuración.
  \item SDL2: para la interfaz gráfica.
  \item SDL2pp: para la interfaz gráfica.
  \item libfmt
\end{enumerate}

En caso de usar Vagrant:
\begin{enumerate}
  \item Vagrant
  \item VirtualBox
\end{enumerate}


\subsection{Common}
Los archivos en común que usan tanto cliente como servidor son:

\begin{enumerate}
  \item Socket
  \item Thread
  \item Queue
  \item DTO: esto incluye todos los tipos de DTO que se envían entre el cliente y el servidor.
  \item Types: esto incluye todos los tipos de datos que se utilizan en el juego.
  \item Manejador de mapas
  \item Configuración: esto son las clases que procesan los archivos de configuración.
\end{enumerate}

\subsection{Servidor}
Dada la necesidad de manejar múltiples conexiones, el servidor tiene una estructura que soporta múltiples hilos.

Al iniciar, el servidor lanza un hilo aceptador, que se encuentra constantemente escuchando el puerto. Cuando el cliente se une, se acpeta esa conexión y se crea a la entidad del jugador, que tiene en sí, sus propios hilos emisor y receptor, así también las colas de mensajes recibidos y a enviar.

Cuando llega un mensaje, este es deserialiado por el deserializador. Una vez deserializado, es ejecutado por los manejadores de los comandos, que dependiendo del tipo de DTO realiza las acciones correspondientes. 

El último hilo que se tiene es el gameloop, que es quien se encarga de actualizar el juego y enviar los mensajes a los clientes. Esto lo hace recibiendo en cada loop las actualizaciones del juego correspondientes y enviádnolas a todos los clientes, es decir, haciendo un broadcast.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Server Threads Classes.png}
  \caption{Diagrama de Clases de los hilos del servidor.}
  \label{fig:server-threads}
\end{figure}

Siendo una estrctura multithreading, se tiene que tener en cuenta la concurrencia. Para ello, se utilizan monitores, que son dos: \texttt{GameMonitor} y \texttt{QueueMonitor}. Ambos utilizan mutex para asegurar que no haya problemas de concurrencia ni race conditions en las actualizaciones de los juegos o procesando comandos. GameMonitor es quien se encarga de actualizar el juego, mientras que QueueMonitor es quien agrega a los clientes a los juegos o realiza un broadcast para informar acerca de una actualización en la partida.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Lobby Command Handlers.png}
  \caption{Lobby Command Handlers.}
  \label{fig:lobby-cmd-handler}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Game Command Handlers.png}
  \caption{Game Command Handlers.}
  \label{fig:game-cmd-hanlder}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Server Game Classes.png}
  \caption{Diagrama de Clases del Modelo del Juego, lado servidor.}
  \label{fig:server-game}
\end{figure}

El servidor se puede cerrar con la tecla \texttt{Q} en cualquier momento.

\subsection{Cliente}
El cliente posee una estructura simple que se puede dividir en dos grandes áreas: gameplay y lobby. El gameplay es la parte del juego donde se muestra el mapa y los jugadores pueden interactuar entre sí. El lobby es la parte del juego donde los jugadores pueden seleccionar su personaje y unirse a una partida.

Ambas partes necesitan enviar y recibir datos desde el servidor. Es por ello que se tienen dos threads, emisor y receptor, que se encargan de enviar y recibir datos respectivamente. Es el cliente mismo quien se encarga de lanzar ambos hilos y también de frenarlos.

Para lograr la comunicación con el servidor, también se poseen tres colas: una para el hilo emisor, donde se encolan los mensajes a enviar; en cuanto al receptor, tiene dos: una para los mensajes recibidos que sean del Lobby y otra para aquellos del Gameplay. 

Antes de ser enviados, los mensajes son serializados, y antes de ser enviados a sus respectivas colas, son deseralizados. Esto se logra a partir de las clases \texttt{Serializer} y \texttt{Deserializer}.

La clase \texttt{Protocolo} es quien realmente conoce cómo es el protocolo de recepción, este es quien realmente procesa la recepción de datos. 

Por último, se tienen los controladores: \texttt{LobbyController} y \texttt{GameController}. Estos tienen a la cola de mensajes recibidos de cada uno y van desencolandolos y, en función del mensaje recibido, realizan las acciones correspondientes.

El juego posee los siguientes comandos:
\begin{enumerate}
  \item Movimientos: estos se realizan con las teclas de dirección hacia la derecha ($\rightarrow$) e izquierda ($\leftarrow$).
  \item Salto: se realiza con la tecla \texttt{espacio}.
  \item Disparo: se realiza con la tecla \texttt{M}.
  \item Correr más rápido: se realiza con la tecla \texttt{SHIFT} de la izquierda.
  \item Cambiar de arma: se realiza con la tecla \texttt{G}.
\end{enumerate}

Además, posee dos Cheats:
\begin{enumerate}
  \item Freezar el juego: se realiza con la tecla \texttt{F3}, con la idea de mantener al ganador del juego imposibilitando que los demás puedan realizar acciones.
  \item Resetear los puntajes: se activa apretando la tecla \texttt{F8}, se realiza con la idea de que haya triple empate en cero.
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Diagrama de Clases Lobby.png}
  \caption{Diagrama de Clases del Lobby.}
  \label{fig:lobby}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/Client.png}
  \caption{Diagrama de Clases del lado cliente.}
  \label{fig:client}
\end{figure}

\subsection{Editor de Niveles}
El editor de niveles es un programa simple que consiste de una sola ventana. En ella, se encuetran un canvas, representando el mapa del juego, y a derecha una lista de elementos que se pueden arrastrar sobre el canvas. De esta manera, se pueden crear nuevos niveles para el juego.

Para obtener cada uno de los elementos, se tiene una lista dentro de la clase, asociada a la categoría y al nombre del elemento. Esto es así debido al formato con el que se crea el mapa, donde el YAML tiene la siguiente estructura:

\begin{lstlisting}[captionpos=b, caption=Ejemplo de formato YAML del mapa]
  CATEGORIA1:
    ELEMENTO_CATEGORIA1_1: [...]
    ...
    ELEMENTO_CATEGORIA1_N: [...]
  ...
  CATEGORIAN:
    ELEMENTO_CATEGORIAN_1: [...]
    ...
    ELEMENTO_CATEGORIAN_M: [...] 
\end{lstlisting}

Los elementos también están asociados a Sprites, que son las imágenes que se pegan sobre el mapa. Para ello, se tiene un archivo YAML donde se tiene por cada elemento, la fuente de la imagen, las coordenadas y el ancho y alto que debe tener el sprite en el mapa real. Al necesitar una, se posee una clase \texttt{SpritesManager}, que obtiene y renderiza las imágenes.

El canvas está compuesto por un \texttt{QGridLayoutWidget} que contiene un \texttt{QGridLayout}. Se le crea a ese elemento perteneciente a la clase \texttt{LevelEditor}, la venta principal, un \texttt{CanvasWidget}, que acepta que se le arrastren y suelten los elementos encima. Cada vez que se suelte un elemento encima de ella, se crea un nuevo \texttt{DroppedElement} y se guarda la posición en la que cayó, en coordenadas del mapa real.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4]{images/Level Editor.png}
  \caption{Diagrama de Clases del Editor de Niveles}
  \label{fig:editor}
\end{figure}

\section{Protocolo}
El protocolo que se diseñó para este Trabajo Práctico utiliza Data Transfer Objects (DTO) para enviar y recibir mensajes tanto desde el lado cliente como del lado servidor.

Se crea un DTO por cada tipo de mensaje: Crear Partida, Unirse a una partida, Obtención de los mapas disponibles, Obtención de las partidas disponibles, Actualización de la partida, Actualización del juego, así como otros que contienen datos acerca de los elementos del juego: jugador, bala, enemigo, ítem, etc.

Cada DTO contiene datos específicos que se deben enviar hacia el otro lado, previamente serializados por el serializador. En la otra punta, el deserializador se encarga de deserializar el mensaje y convertirlo en un DTO para ser usado.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.28, angle=270]{images/DTO Hierarchy.png}
  \caption{Jerarquía de los Data Travel Objects.}
  \label{fig:dto}
\end{figure}


\section{Vagrant e Instalador}
Se provee un archivo \texttt{Vagrantfile} que permite crear una máquina virtual con todas las dependencias necesarias para compilar y ejecutar el proyecto. Para ello, se debe tener instalado Vagrant y VirtualBox.

El archivo crea una máquina virtual utilizando la box \texttt{jammy64}, que utiliza el sistema operativo Ubuntu 22.04 y contiene todas las dependencias que se precisan para compilar y ejecutar el proyecto. 
Ejecutando \texttt{vagrant up --provision}, se crea la máquina virtual y se instalan las dependencias. Luego, se puede acceder a la máquina virtual con \texttt{vagrant ssh} y compilar y ejecutar el proyecto.

\section{Compilación y Ejecución}
Para compilar el proyecto, se debe ejecutar los siguientes comandos en la terminal sobre el directorio del proyecto:

\begin{lstlisting}[language=sh,caption=Compilación del Proyecto, captionpos=b]
  $ sudo rm -rf build # Si es que existe una carpeta build previa
  $ mkdir -p build
  $ cd build
  $ cmake ..
  $ make -j$(nproc) # Alternativamente, make -j4
\end{lstlisting}

Una vez compilado, para ejecutar el servidor se debe correr:

\begin{lstlisting}[language=sh,caption=Ejecución del Servidor, captionpos=b]
  $ ./jazzserver <port> # Reemplazar <port> por un puerto a elección
\end{lstlisting}

Para ejecutar el cliente, se debe ejecutar:

\begin{lstlisting}[language=sh,caption=Ejecución del Cliente, captionpos=b]
  $ ./jazzclient <ip> <port> # Reemplazar <ip> por la IP del servidor (localhost) y <port> por el puerto
\end{lstlisting}

Por último, para el editor de niveles:

\begin{lstlisting}[language=sh,caption=Ejecución del Editor de Niveles, captionpos=b]
  $ ./leveleditor
\end{lstlisting}

\subsection{Utilizando Vagrant}
Se provee también un archivo \texttt{Vagrantfile} que permite crear una máquina virtual con todas las dependencias necesarias para compilar y ejecutar el proyecto. Para ello, se debe tener instalado Vagrant y VirtualBox.

Para crear la máquina virtual y correr el proyecto, en la carpeta donde se bajó el código del repositorio, se debe ejecutar:

\begin{lstlisting}[language=sh,caption=Creación de la Máquina Virtual, captionpos=b]
  $ vagrant up  --provision
  $ vagrant ssh
  $ cd /home/vagrant/jazz_jackrabbit_2/build
  $ ./jazzserver <port> # Para correr el servidor, reemplazar <port> por un puerto a elección
  $ ./jazzclient <ip> <port> # Para correr el cliente, reemplazar <ip> por la IP del servidor (localhost) y <port> por el puerto
  $ ./leveleditor # Para ejecutar el editor de niveles
\end{lstlisting}

El archivo \texttt{Vagrantfile} se encarga de instalar las dependencias necesarias y compilar el proyecto. Para correr el servidor y el cliente, se debe ejecutar el servidor primero y luego el cliente.

Para salir de Vagrant, una vez finalizada la ejecución:

\begin{lstlisting}[language=sh,caption=Salir de Vagrant, captionpos=b]
  $ exit
  $ vagrant halt
  $ vagrant destroy # Si se desea borrar la máquina virtual
\end{lstlisting}

\section{Pruebas}
Para correr las pruebas, se debe ejecutar el siguiente comando en la terminal, sobre el directorio \texttt{build}, el comando \texttt{./tests}.

Se realizaron algunas pruebas unitarias para verificar el correcto funcionamiento del protocolo, creándose un socket mock y verificando las llamadas al mismo, así como el resultado de la serialización y deserialización de los mensajes.

\end{document}